/*
    首先这一题其实就是一个kmp的算法，
    1. 首先是匹配的过程；这个过程相对来说比较简单，就是循环遍历两个串；
    有点类似有双指针；首先两个串的存储是从1开始的，这样会比较简单。如果
    下标是从0开始，那么就是多很多不必要的麻烦；
    在匹配的过程中，原串是从1开始，而模式串（子串是从0开始的）；然后就
    遍历匹配（i 和 j + 1），如果两个数不相等，那么j就退回到next[j]的位置；
    当j退回到0那么就不能够在退了。那么就直接退出循环。但此时i 和 j + 1相等时，
    那么j++；若此时j = n，则匹配完成，那么输出之前匹配的起始位置即可，然后将j
    置为next[j]（一开始我个人的理解是将其置为0；但是原串中的字符串就无法进行匹配了，
    所以此时也需要将j置为一个失配的处理直接赋值为next[j]）；
    2. 上面是匹配的过程，这里是next数组的过程。这个过程大致是和上面的一样的。
    只不过这里比较的是两个相同的字符串也就是子串。而对于求next[j]，说白了其实
    也就是求到j为止的最大的和前缀相等的后缀。
    首先对于next[1]而言，就是0；所以此时循环从2（i）开始（此时这里也是考虑到了前缀的相关的问题），而j等于0；
    当i != j + 1时，那么j就需要退回到next[j]，当然j退回到0时，就不可在退了；而当其相等时，那么j++；并将
    此时的next[i]的值赋值为j；由此也就是求出了next值
    ps：个人感觉这种真的很巧妙
*/
#include<iostream>

using namespace std;
extern const int N = 1e5 + 10, M = 1e6 + 10;
// 初始化数组
char p[N], s[M];
int ne[N];
int main()
{
    int n{0}, m{0};
    // 两个串都是从1开始存储数据
    cin >> n >> p + 1 >> m >> s + 1;
    // next数组
    for(int i = 2, j = 0; i <= n; i++){
        while(j && p[i] != p[j + 1]) j = ne[j];
        if(p[i] == p[j + 1]) j++;
        ne[i] = j;
    }
    // i从1开始，j从0开始
    for(int i = 1, j = 0; i <= m; i++){
        while(j && s[i] != p[j + 1]) j = ne[j];
        // 继续向后面匹配
        if(s[i] == p[j + 1]) j++;
        // 匹配成功
        if(j == n){
            cout << i - n << ' ';
            j = ne[j];
        }
    }
    cout << endl;
    return 0;
}